# Security Vulnerability Analysis: Cross-User API Key Access

## Executive Summary

A critical security vulnerability was discovered in the Snappy MCP Server where all users' requests were being executed using a single user's API key. This occurred due to improper KV storage queries that searched across all users' entries rather than being scoped to individual users.

## Timeline of Discovery

1. **Initial Report**: User reported that "anyone using the system has access to my workspaces" and that even when users save their own API tokens, the system still uses the original user's token.

2. **Investigation**: Through analysis of request history, we confirmed all requests were being made with user_id: `17b6fc02-966c-4642-babe-e8004afffc46` regardless of which user initiated them.

3. **Root Cause Identified**: The `getFreshApiKey()` method was searching for API keys across ALL users in KV storage, not just the current user.

## Technical Deep Dive

### The Architecture

The system involves multiple token types and storage mechanisms:

1. **Token Types**:
   - **OAuth Access Token**: Generated by the worker for client authentication
   - **Xano Auth Token**: Generated by backend after email/password login
   - **API Key**: Stored in user profile for Xano Meta API access

2. **Storage Locations**:
   - **Database (users table)**: Stores user profiles with API keys
   - **KV Storage**: Caches authentication data for worker access
   - **Worker Props**: In-memory storage that doesn't persist across hibernation

### The Authentication Flow

1. User registers on snappy.ai frontend
2. User saves their Xano API key via `save_api_key` endpoint â†’ stored in database
3. User initiates MCP client which triggers OAuth flow
4. OAuth flow authenticates user and stores tokens in KV storage
5. Worker uses KV storage to retrieve API keys for subsequent requests

### The Vulnerability

#### Primary Issue: Unscoped KV Queries

In `/src/index.ts`, the `getFreshApiKey()` method contained:

```typescript
// VULNERABLE CODE
const authEntries = await this.env.OAUTH_KV.list({ prefix: 'xano_auth_token:' });

if (authEntries.keys && authEntries.keys.length > 0) {
    const authDataStr = await this.env.OAUTH_KV.get(authEntries.keys[0].name);
    // ... checks if userId matches ...
}
```

**The Problem**: This searches for ALL entries with prefix `xano_auth_token:` across ALL users, then takes the FIRST entry found. If User A's entry comes first, User B's worker would read User A's data.

#### Secondary Issue: Hardcoded Fallbacks

The `auth_config` table contained hardcoded API keys (entries 8 and 9) that were used as system-wide fallbacks when KV lookups failed.

### Why This Happened

1. **Worker Hibernation**: When workers wake from hibernation, props are empty
2. **KV Search Logic**: The code searched globally instead of per-user
3. **Fallback Chain**: When user-specific lookups failed, it fell back to any available API key
4. **No User Isolation**: KV queries weren't scoped to individual users

## Evidence Collected

### Request History Analysis

All requests to Xano were using the same user_id regardless of who initiated them:

```json
{
  "user_id": "17b6fc02-966c-4642-babe-e8004afffc46",
  "tool_name": "xano_browse_request_history",
  "session_id": "session-17b6fc02-966c-4642-babe-e8004afffc46-..."
}
```

### Auth Config Discovery

Found hardcoded API keys in the database:
- Entry ID 8: Contains full API key starting with `eyJhbGciOiJSUzI1NiJ9...`
- Entry ID 9: Duplicate of the same API key

### API Key Update Issues

Users reported that after saving their API key on the frontend:
1. The save appears successful (200 response)
2. But the MCP server continues using the old/wrong API key
3. Some users see empty API key saves (400 responses)

## The Fix

### Immediate Actions Taken

1. **Deleted Hardcoded Keys**: Removed auth_config entries 8 and 9
2. **Updated User Record**: Set the affected user's API key to a new value

### Code Fix Required

Change the KV queries to be user-scoped:

```typescript
// FIXED CODE
// Search only for the current user's entries
const authEntries = await this.env.OAUTH_KV.list({ 
    prefix: `xano_auth_token:${this.props.userId}` 
});

// Similarly for token entries
const tokenEntries = await this.env.OAUTH_KV.list({ 
    prefix: `token:${this.props.userId}` 
});
```

### Additional Improvements Needed

1. **Fresh API Key Retrieval**: Implement fetching current API key from database instead of relying solely on KV cache
2. **Remove All Hardcoded Values**: Audit entire codebase for any hardcoded credentials
3. **Add User Isolation Checks**: Ensure all KV operations are scoped to individual users

## Testing Strategy

1. **Create Test Users**: Register new users from different locations
2. **Verify Isolation**: Confirm each user only accesses their own data
3. **Test API Key Updates**: Verify that updating API key on frontend reflects in MCP operations
4. **Monitor Request History**: Check that user_ids in requests match the authenticated user

## Lessons Learned

1. **Always Scope KV Queries**: Never use broad prefixes that could return data from multiple users
2. **No Hardcoded Credentials**: Never store credentials in configuration tables
3. **Verify User Isolation**: Always test multi-user scenarios during development
4. **Audit Trail**: Request history was crucial in identifying this issue

## Prevention Measures

1. **Code Review Focus**: Pay special attention to KV storage operations
2. **Testing Protocol**: Always test with multiple user accounts
3. **No Shared State**: Ensure each user's session is completely isolated
4. **Regular Audits**: Periodically check request history for anomalies

## Impact Assessment

- **Severity**: Critical - Users could access each other's workspaces
- **Scope**: All users of the Snappy MCP system
- **Duration**: Unknown - issue was present since initial deployment
- **Data Exposure**: Users could potentially view/modify other users' Xano data

## Conclusion

This vulnerability arose from a combination of:
1. Improper KV storage queries that weren't user-scoped
2. Hardcoded fallback credentials in the database
3. Lack of proper user isolation in the authentication flow

The fix is straightforward but critical: ensure all KV queries are scoped to individual users and remove all hardcoded credentials from the system.